//! Core traits and types for the Artemis framework.
//!
//! This module defines the main abstractions used throughout the framework:
//! - [`Collector`]: Sources of events
//! - [`Strategy`]: Event processing logic that generates actions
//! - [`Executor`]: Action handlers that execute the final operations
//!
//! It also provides utility types like [`CollectorMap`] and [`ExecutorMap`] for
//! transforming data between different types.

use std::pin::Pin;

use async_trait::async_trait;
use eyre::Result;
use tokio_stream::{Stream, StreamExt};

/// A stream of events emitted by a [`Collector`].
///
/// This type alias represents a pinned, boxed stream that yields events of type `E`.
/// The stream is `Send` to allow it to be used across async task boundaries.
pub type CollectorStream<'a, E> = Pin<Box<dyn Stream<Item = E> + Send + 'a>>;

/// Trait for event sources that generate streams of events.
///
/// Collectors are responsible for gathering events from external sources
/// (e.g., blockchain events, API calls, file system changes) and providing
/// them as an async stream to the engine.
///
/// # Example
///
/// ```rust,ignore
/// use artemis::types::{Collector, CollectorStream};
/// use async_trait::async_trait;
/// use eyre::Result;
///
/// struct MyCollector;
///
/// #[async_trait]
/// impl Collector<String> for MyCollector {
///     fn name(&self) -> &str {
///         "MyCollector"
///     }
///
///     async fn get_event_stream(&self) -> Result<CollectorStream<'_, String>> {
///         // Implementation that returns a stream of String events
///         todo!()
///     }
/// }
/// ```
#[async_trait]
pub trait Collector<E>: Send + Sync {
    /// Returns the name of this collector for logging and debugging purposes.
    ///
    /// The default implementation returns "Unnamed".
    fn name(&self) -> &str {
        "Unnamed"
    }

    /// Returns the core event stream for the collector.
    ///
    /// This method should return a stream that yields events of type `E`.
    /// The stream will be consumed by the engine and events will be forwarded
    /// to all registered strategies.
    ///
    /// # Errors
    ///
    /// Returns an error if the event stream cannot be created or initialized.
    async fn get_event_stream(&self) -> Result<CollectorStream<'_, E>>;
}

/// Trait for event processing logic that converts events into actions.
///
/// Strategies contain the core business logic of your application. They receive
/// events from collectors, process them according to your requirements, and
/// generate actions that will be executed by executors.
///
/// # Example
///
/// ```rust,ignore
/// use artemis::types::Strategy;
/// use async_trait::async_trait;
/// use eyre::Result;
///
/// struct MyStrategy;
///
/// #[async_trait]
/// impl Strategy<String, String> for MyStrategy {
///     fn name(&self) -> &str {
///         "MyStrategy"
///     }
///
///     async fn sync_state(&mut self) -> Result<()> {
///         // Initialize strategy state if needed
///         Ok(())
///     }
///
///     async fn process_event(&mut self, event: String) -> Vec<String> {
///         // Process the event and return actions
///         vec![format!("Action for: {}", event)]
///     }
/// }
/// ```
#[async_trait]
pub trait Strategy<E, A>: Send + Sync {
    /// Returns the name of this strategy for logging and debugging purposes.
    ///
    /// The default implementation returns "Unnamed".
    fn name(&self) -> &str {
        "Unnamed"
    }

    /// Synchronizes the initial state of the strategy.
    ///
    /// This method is called once when the engine starts, before any events
    /// are processed. Use it to initialize any state that your strategy needs,
    /// such as fetching initial data from external sources.
    ///
    /// The default implementation does nothing and returns `Ok(())`.
    ///
    /// # Errors
    ///
    /// Returns an error if the state synchronization fails. This will prevent
    /// the engine from starting.
    async fn sync_state(&mut self) -> Result<()> {
        Ok(())
    }

    /// Processes an event and returns a vector of actions to execute.
    ///
    /// This is the core method where your business logic lives. It receives
    /// an event of type `E` and should return zero or more actions of type `A`
    /// that should be executed in response to this event.
    ///
    /// # Arguments
    ///
    /// * `event` - The event to process
    ///
    /// # Returns
    ///
    /// A vector of actions to execute. An empty vector means no action should
    /// be taken for this event.
    async fn process_event(&mut self, event: E) -> Vec<A>;
}

/// Trait for action handlers that execute the final operations.
///
/// Executors are responsible for taking actions generated by strategies and
/// performing the actual work, such as sending transactions, making API calls,
/// or writing to databases.
///
/// # Example
///
/// ```rust,ignore
/// use artemis::types::Executor;
/// use async_trait::async_trait;
/// use eyre::Result;
///
/// struct MyExecutor;
///
/// #[async_trait]
/// impl Executor<String> for MyExecutor {
///     fn name(&self) -> &str {
///         "MyExecutor"
///     }
///
///     async fn execute(&self, action: String) -> Result<()> {
///         println!("Executing action: {}", action);
///         Ok(())
///     }
/// }
/// ```
#[async_trait]
pub trait Executor<A>: Send + Sync {
    /// Returns the name of this executor for logging and debugging purposes.
    ///
    /// The default implementation returns "Unnamed".
    fn name(&self) -> &str {
        "Unnamed"
    }

    /// Executes an action.
    ///
    /// This method receives actions generated by strategies and should perform
    /// the corresponding operations. The execution should be idempotent when
    /// possible, as actions might be retried in case of failures.
    ///
    /// # Arguments
    ///
    /// * `action` - The action to execute
    ///
    /// # Errors
    ///
    /// Returns an error if the action execution fails. Errors are logged by
    /// the engine but don't stop the processing of other actions.
    async fn execute(&self, action: A) -> Result<()>;
}

/// A wrapper around a [`Collector`] that maps outgoing events to a different type.
///
/// This utility allows you to transform events from one type to another as they
/// flow from the collector to strategies. This is useful when you need to adapt
/// a collector that produces one event type to work with strategies that expect
/// a different event type.
///
/// # Example
///
/// ```rust,ignore
/// use artemis::types::CollectorMap;
///
/// let original_collector: Box<dyn Collector<i32>> = Box::new(my_collector);
/// let mapped_collector = CollectorMap::new(
///     original_collector,
///     |num| format!("Number: {}", num)
/// );
/// // Now produces String events instead of i32 events
/// ```
pub struct CollectorMap<E, F> {
    collector: Box<dyn Collector<E>>,
    f: F,
}

impl<E, F> CollectorMap<E, F> {
    /// Creates a new `CollectorMap` that transforms events using the provided function.
    ///
    /// # Arguments
    ///
    /// * `collector` - The original collector to wrap
    /// * `f` - A function that transforms events from type `E1` to type `E2`
    pub fn new(collector: Box<dyn Collector<E>>, f: F) -> Self {
        Self { collector, f }
    }
}

#[async_trait]
impl<E1, E2, F> Collector<E2> for CollectorMap<E1, F>
where
    E1: Send + Sync + 'static,
    E2: Send + Sync + 'static,
    F: Fn(E1) -> E2 + Send + Sync + Clone + 'static,
{
    fn name(&self) -> &str {
        self.collector.name()
    }
    async fn get_event_stream(&self) -> Result<CollectorStream<'_, E2>> {
        let stream = self.collector.get_event_stream().await?;
        let f = self.f.clone();
        let stream = stream.map(f);
        Ok(Box::pin(stream))
    }
}

/// A wrapper around an [`Executor`] that maps incoming actions to a different type.
///
/// This utility allows you to transform actions from one type to another before
/// they reach the executor. This is useful when you need to adapt strategies that
/// produce one action type to work with executors that expect a different action type.
///
/// The mapping function returns an `Option`, allowing you to filter out certain
/// actions by returning `None`.
///
/// # Example
///
/// ```rust,ignore
/// use artemis::types::ExecutorMap;
///
/// let original_executor: Box<dyn Executor<String>> = Box::new(my_executor);
/// let mapped_executor = ExecutorMap::new(
///     original_executor,
///     |num: i32| if num > 0 { Some(format!("Positive: {}", num)) } else { None }
/// );
/// // Now accepts i32 actions and filters/transforms them to String actions
/// ```
pub struct ExecutorMap<A, F> {
    executor: Box<dyn Executor<A>>,
    f: F,
}

impl<A, F> ExecutorMap<A, F> {
    /// Creates a new `ExecutorMap` that transforms actions using the provided function.
    ///
    /// # Arguments
    ///
    /// * `executor` - The original executor to wrap
    /// * `f` - A function that transforms actions from type `A1` to `Option<A2>`.
    ///   Returning `None` will skip execution for that action.
    pub fn new(executor: Box<dyn Executor<A>>, f: F) -> Self {
        Self { executor, f }
    }
}

#[async_trait]
impl<A1, A2, F> Executor<A1> for ExecutorMap<A2, F>
where
    A1: Send + Sync + 'static,
    A2: Send + Sync + 'static,
    F: Fn(A1) -> Option<A2> + Send + Sync + Clone + 'static,
{
    fn name(&self) -> &str {
        self.executor.name()
    }

    async fn execute(&self, action: A1) -> Result<()> {
        let action = (self.f)(action);
        match action {
            Some(action) => self.executor.execute(action).await,
            None => Ok(()),
        }
    }
}

pub struct Module;

impl Module {
    pub const COLLECTOR: &'static str = "collector";
    pub const STRATEGY: &'static str = "strategy";
    pub const EXECUTOR: &'static str = "executor";
    pub const ENGINE: &'static str = "engine";
}
